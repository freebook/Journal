<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
	"/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [
	<!ENTITY article.author.xml 	SYSTEM "../common/article.author.xml">
	<!ENTITY book.info.abstract.xml	SYSTEM "../common/book.info.abstract.xml">
]>
<article xml:base="http://netkiller.github.io/journal/"
	xmlns="http://docbook.org/ns/docbook" xml:lang="zh-cn">
	<articleinfo>
		<title>数据库进程间通信解决方案之MQ</title>
		<subtitle>http://netkiller.github.io/journal/mysql.plugin.mq.html</subtitle>
		&article.author.xml;
		<pubdate>$Date: 2013-12-16 13:34:20 +0800 (Thu, 16 May 2013) $</pubdate>
		<releaseinfo>$Id: mysql-plugin.xml 587 2013-12-16 14:00:00Z netkiller $</releaseinfo>
		<abstract>
			<para>你是否想过当数据库中的数据发生变化的时候出发某种操作？但因数据无法与其他进程通信（传递信号）让你放弃，而改用每隔一段时间查询一次数据变化的方法？下面的插件可以解决你的问题。</para>
			<para>原文出处：<ulink url="http://netkiller.github.io/journal/mysql.plugin.fifo.html"/></para>
		</abstract>
		&book.info.abstract.xml;
		<keywordset>
			<keyword>mysql</keyword>
			<keyword>plugin, udf</keyword>
			<keyword>images</keyword>
		</keywordset>
	</articleinfo>

	<section>
		<title>背景</title>
		<para>之前我发表过一篇文章 http://netkiller.github.io/journal/mysql.plugin.fifo.html</para>
		<para>该文章中提出了通过fifo 管道，实现数据库与其他进程的通信。属于 IPC 机制(同一个OS/服务器内)，后我有采用ZeroMQ重新实现了一个 RPC 机制的方案，同时兼容IPC（跨越OS/服务器）</para>
		<para>各种缩写的全称 IPC(IPC :Inter-Process Communication 进程间通信)，ITC(ITC : Inter Thread Communication 线程间通信)与RPC(RPC: Remote Procedure Calls远程过程调用)。</para>
		<para>支持协议</para>
		<screen>
inproc://my_publisher
tcp://server001:5555
ipc:///tmp/feeds/0
		</screen>
		
		<para></para>
	</section>
	<section>
		<title>Mysql plugin</title>
		<para> 我开发了几个 UDF, 共4个 function</para>
		<variablelist>
			<title>UDF</title>
			<varlistentry>
				<term>zmq_client(sockt,message)</term>
				<listitem>
					<para>sockt .成功返回true,失败返回flase.</para>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>有了上面的function后你就可以在begin,commit,rollback 直接穿插使用，实现在事物处理期间做你爱做的事。也可以用在触发器与EVENT定时任务中。</para>
	</section>
	<section>
		<title>plugin 的开发与使用</title>
		<para>编译UDF你需要安装下面的软件包</para>
		<screen>
sudo apt-get install pkg-config
sudo apt-get install libmysqlclient-dev

sudo apt-get install gcc gcc-c++ make cmake
		</screen>
		<para><ulink url="https://github.com/netkiller/mysql-zmq-plugin" /></para>
		<para>编译udf，最后将so文件复制到 /usr/lib/mysql/plugin/</para>
		<screen>
		<![CDATA[
git clone https://github.com/netkiller/mysql-zmq-plugin.git
cd mysql-zmq-plugin

cmake .
make && make install
		]]>
		</screen>
		<para>装载</para>
		<screen>
create function zmq_client returns string soname 'libzeromq.so';
create function zmq_publish returns string soname 'libzeromq.so';
		</screen>
		<para>卸载</para>
		<screen>
drop function zmq_client;
drop function zmq_publish;
		</screen>
		
		<para>确认安装成功</para>
		<screen>
		<![CDATA[
mysql> SELECT * FROM `mysql`.`func` where name like 'zmq%';
+-------------+-----+--------------+----------+
| name        | ret | dl           | type     |
+-------------+-----+--------------+----------+
| zmq_client  |   0 | libzeromq.so | function |
| zmq_publish |   0 | libzeromq.so | function |
+-------------+-----+--------------+----------+
2 rows in set (0.00 sec)
		]]>
		</screen>
	</section>
	<section>
		<title>插件如何使用</title>
		<para>插件有很多种用法，这里仅仅一个例</para>
		<para>编译zeromq server 测试程序</para>
		<screen>
cd test
cmake .
make
		</screen>
		
		<para>启动服务进程</para>
		<screen>
./server
		</screen>

		<para>发送Hello world! </para>
		<screen>
		<![CDATA[
mysql> select zmq_client('tcp://localhost:5555','Hello world!');
+---------------------------------------------------+
| zmq_client('tcp://localhost:5555','Hello world!') |
+---------------------------------------------------+
| Hello world! OK                                   |
+---------------------------------------------------+
1 row in set (0.01 sec)
		]]>
		</screen>
		<para>查看服务器端是否接收到信息。</para>
		<screen>
$ ./server
Received: Hello world!
		</screen>		

		<para>我们再将上面的例子使用触发器进一步优化</para>
		<screen>
		<![CDATA[
mysql> select zmq_client('tcp://localhost:5555',mobile) from demo;
+-------------------------------------------+
| zmq_client('tcp://localhost:5555',mobile) |
+-------------------------------------------+
| 13113668891 OK                            |
| 13113668892 OK                            |
| 13113668893 OK                            |
| 13322993040 OK                            |
| 13588997745 OK                            |
+-------------------------------------------+
5 rows in set (0.03 sec)
		]]>
		</screen>
		<para>服务器端已经接收到数据库发过来的信息</para>
		<screen>
$ ./server
Received: Hello world!
Received: 13113668891
Received: 13113668892
Received: 13113668893
Received: 13322993040
Received: 13588997745
		</screen>		
		<para>我们可以拼装json或者序列化数据，发送给远端</para>
		<screen>
		<![CDATA[
mysql> select zmq_client('tcp://localhost:5555',concat('{name:',name,', tel:',mobile,'}')) from demo;
+------------------------------------------------------------------------------+
| zmq_client('tcp://localhost:5555',concat('{name:',name,', tel:',mobile,'}')) |
+------------------------------------------------------------------------------+
| {name:neo, tel:13113668891} OK                                               |
| {name:jam, tel:13113668892} OK                                               |
| {name:leo, tel:13113668893} OK                                               |
| {name:jerry, tel:13322993040} OK                                             |
| {name:tom, tel:13588997745} OK                                               |
+------------------------------------------------------------------------------+
5 rows in set (0.03 sec)
		]]>
		</screen>
		<para>返回数据取决于你服务端怎么编写处理程序，你可以返回true/false等等。</para>
		<para>触发器以及事务处理，这里就不演示了</para>
	</section>
</article>
