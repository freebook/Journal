<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN"
	"/usr/share/xml/docbook/schema/dtd/5.0/docbook.dtd" [
	<!ENTITY article.author.xml 		SYSTEM "../common/article.author.xml">
	<!ENTITY book.info.legalnotice.xml 	SYSTEM "../common/book.info.legalnotice.xml">
	<!ENTITY book.info.abstract.xml		SYSTEM "../common/book.info.abstract.xml">
]>
<article xml:base="http://netkiller.github.io/journal/" xmlns="http://docbook.org/ns/docbook"
	xml:lang="zh-cn">
	<articleinfo>
		<title>hyperledger v1.0.5 区块链运维入门</title>
		<subtitle></subtitle>
		&article.author.xml;
		&book.info.legalnotice.xml;
		<abstract>
			<para>网上搜索hyperledger大部分文章是讲解开发环境配置的，安装哪些文章配置好开发环境，写好合约，怎样落地呢？却很少文章提及。</para>
			<para>要将区块链落地，我们必须依赖运维技术，这是IT基础设施，区块链应用将建立在这个基础设施之上，否则区块链就是浮云。</para>
		</abstract>
		&book.info.abstract.xml;
		<keywordset>
			<keyword></keyword>
			<keyword></keyword>
			<keyword></keyword>
			<keyword></keyword>
		</keywordset>
		<pubdate>$Date$</pubdate>
		<release>$Id$</release>
	</articleinfo>
	<section id="background">
		<title>背景</title>
		<para>由于区块链是区中心化，与传统运维不同，所以之前你积累的经验，不一定适用于区块链。要想运维好区块链项目，就必须理解去中心化这个概念。</para>
		<para>首先谈谈传统运维，总结为三个字“中心化”，当然有人反对并抛出“分布式”感念，传统运维的分布式仍然建立在中心化的基础之上。</para>
		<para>我们来看看传统应用模式，决多数应用都可以概括为：</para>
		<literallayout>
		<![CDATA[
用户 -> WEB -> Application -> Cache -> Database 
		]]>
		</literallayout>
		<para>可以在这个体系下面做灵活变化，例如加入所有引擎、分布式文件系统，大数据等等应用，但都离不开这个模式。</para>
		<para>区块链完全不同，如果举一个最接近的例子，我想可能与多数据中心远程异地灾备比较接近。</para>

	</section>
	<section id="overview">
		<title>部署拓扑</title>
		<para>什么是区块链呢？
			区块链实际上就是数据库，一个只能插入和查询的数据库，数据不能被修改和删除，并且这个数据库没有DBA管理员角色。这么一说你应该明白了把，实际上运维区块链就是在维护一个分布式数据库。</para>
		<para>网上的绝大多数安装例子中，均采用 docker
			部署方案，但无一例外的是，全部安装在一个物理机上。如果是生产环境，我们必须分开不是，首先要做的工作是化整为零，拆解应用，搞明白每个容器的功能和作用。然后我们将应用拆分，独立部署到物理节点上去。</para>
		<literallayout>
		<![CDATA[
       +---------------------------------+		
       |        	       SDK               |
       +---------------------------------+	
       | golang | nodejs | python | java |
       +---------------------------------+			
	                  |
	                  V
       +---------------------------------+				
       |           fabric-ca             |
       +---------------------------------+
           |                       |
+-------------------+     +-------------------+
|	Peer            |     |  Peer             |	        
+-------------------+     +-------------------+		
     |                       |
     V                       V
+-------------------+     +-------------------+
| Orderer           |     | Orderer           |
+-------------------+     +-------------------+
                 |           |
             +-------------------+
             | Couchdb           |
             +-------------------+	
		]]>
		</literallayout>
		<para>接下来我们要做的工作是将上面拓扑图种的技术点分分击破。</para>

		<para>由于 Hyperledger Fabric 是建立在 Docker 基础之上的。所以不建议你去除 Docker
			转而使用传统的本地编译安装方式。我们仍然保持使用 Docker 在每个物理节点上，这回省去软件的编译和安装环节。</para>
		<section id="depends">
			<title>依赖关系</title>
			<para>需要注意的是于其他传统系统一样，Hyperledger Fabric 的启动也是有顺序的，这是因为他们之间存在着依赖关系。</para>
		</section>
	</section>
	<section id="">
		<title>生成证书和创世区块</title>
		<para>这里我们需要几个命令（configtxgen configtxlator cryptogen），官方的安装方式：</para>
		<screen>
		<![CDATA[
curl -sSL https://goo.gl/byy2Qj | bash -s 1.0.5
		]]>
		</screen>
		<para>无论如何我都安装不成功，可能是（https://goo.gl/byy2Qj）被天朝给墙了。不过我发现 fabric-tools
			里面有这个工具。</para>
		<tip>
			<para>经过翻墙发现 https://goo.gl/byy2Qj 地址是 301 到下面地址：</para>
			<para>
				<ulink
					url="https://raw.githubusercontent.com/hyperledger/fabric/v1.0.5/scripts/bootstrap.sh" />
			</para>
		</tip>
		<screen>
		<![CDATA[
[root@localhost ~]# mkdir netkiller
[root@localhost ~]# cd netkiller/
[root@localhost netkiller]# mkdir -p {chaincode,crypto-config,config,artifacts}	
		]]>
		</screen>

		<section id="">
			<title>创建配置文件</title>

			<section id="">
				<title>crypto-config.yaml</title>

				<para>创建证书</para>
				<screen>
				<![CDATA[
OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 1
    Users:
      Count: 1			
				]]>
				</screen>
				<para>如果有多个Peer节点参考下面配置。</para>
				<screen>
				<![CDATA[
[root@localhost netkiller]# vim crypto-config.yaml

OrdererOrgs:
  - Name: Orderer
    Domain: example.com
    Specs:
      - Hostname: orderer
PeerOrgs:
  - Name: Org1
    Domain: org1.example.com
    Template:
      Count: 2
    Users:
      Count: 1
  - Name: Org2
    Domain: org2.example.com
    Template:
      Count: 2
    Users:
      Count: 1
				]]>
				</screen>
			</section>
			<section id="">
				<title>configtx.yaml</title>
				<screen>
				<![CDATA[
---
Profiles:

    OneOrgOrdererGenesis:
        Orderer:
            <<: *OrdererDefaults
            Organizations:
                - *OrdererOrg
        Consortiums:
            SampleConsortium:
                Organizations:
                    - *Org1
    OneOrgChannel:
        Consortium: SampleConsortium
        Application:
            <<: *ApplicationDefaults
            Organizations:
                - *Org1

Organizations:

    - &OrdererOrg
        Name: OrdererOrg

        ID: OrdererMSP

        MSPDir: crypto-config/ordererOrganizations/example.com/msp

    - &Org1
        Name: Org1MSP

        ID: Org1MSP

        MSPDir: crypto-config/peerOrganizations/org1.example.com/msp

        AnchorPeers:
            - Host: peer0.org1.example.com
              Port: 7051

Orderer: &OrdererDefaults

    OrdererType: solo

    Addresses:
        - orderer.example.com:7050

    BatchTimeout: 2s

    BatchSize:

        MaxMessageCount: 10

        AbsoluteMaxBytes: 99 MB

        PreferredMaxBytes: 512 KB

    Kafka:
        Brokers:
            - 127.0.0.1:9092

    Organizations:

Application: &ApplicationDefaults

    Organizations:
				]]>
				</screen>
			</section>
		</section>

		<section id="">
			<title>启动 fabric-tools 容器</title>
			<para>创建文件 docker-compose-fabric-tools.yml</para>
			<screen>
			<![CDATA[
version: '2'

networks:
  basic:

services:
  tools:
    container_name: tools 
    image: hyperledger/fabric-tools
    tty: true
    environment:
      - GOPATH=/opt/gopath
      - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
      - CORE_LOGGING_LEVEL=DEBUG
      - CORE_PEER_ID=cli
      - CORE_PEER_ADDRESS=peer0.org1.example.com:7051
      - CORE_PEER_LOCALMSPID=Org1MSP
      - CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
      - CORE_CHAINCODE_KEEPALIVE=10
    # working_dir: /opt/gopath/src/github.com/hyperledger/fabric/peer
    working_dir: /root/netkiller
    command: /bin/bash
    volumes:
        - /var/run/:/host/var/run/
        - ~/netkiller:/root/netkiller
        - ./chaincode/:/opt/gopath/src/github.com/
        - ./crypto:/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/
    networks:
        - basic
			]]>
			</screen>
			<section id="">
				<title>启动 Docker 容器</title>
				<para>启动 Docker 容器</para>
				<screen>
				<![CDATA[
[root@localhost netkiller]# docker-compose -f docker-compose-fabric-tools.yml up -d
Creating tools
				]]>
				</screen>
				<para>进入容器</para>
				<screen>
				<![CDATA[
[root@localhost netkiller]# docker-compose -f docker-compose-fabric-tools.yml exec tools bash
root@88e9040d2d2a:/opt/gopath/src/github.com/hyperledger/fabric/peer#				
				]]>
				</screen>
			</section>
			<section id="">
				<title>生成证书</title>
				<para>命令</para>
				<screen>
				<![CDATA[
cryptogen generate --config=./crypto-config.yaml
				]]>
				</screen>
				<para>演示</para>
				<screen>
				<![CDATA[
root@8f467a88de99:~/netkiller# cryptogen generate --config=./crypto-config.yaml
org1.example.com
org2.example.com				

root@8f467a88de99:~/netkiller# ls -1 crypto-config
ordererOrganizations
peerOrganizations
				]]>
				</screen>
			</section>
			<section id="">
				<title>生成创世区块</title>
				<screen>
				<![CDATA[
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgOrdererGenesis -outputBlock ./config/genesis.block
2018-02-08 08:35:30.121 UTC [common/configtx/tool] main -> INFO 001 Loading configuration
2018-02-08 08:35:30.236 UTC [common/configtx/tool] doOutputBlock -> INFO 002 Generating genesis block
2018-02-08 08:35:30.238 UTC [common/configtx/tool] doOutputBlock -> INFO 003 Writing genesis block			
				]]>
				</screen>

			</section>
			<section id="">
				<title>生成通道配置文件</title>
				<para>命令</para>
				<screen>
				<![CDATA[
CHANNEL_NAME=mychannel
configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME				
				]]>
				</screen>
				<para>操作演示</para>
				<screen>
				<![CDATA[
root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputCreateChannelTx ./config/channel.tx -channelID $CHANNEL_NAME 
2018-02-08 08:41:08.010 UTC [common/configtx/tool] main -> INFO 001 Loading configuration
2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -> INFO 002 Generating new channel configtx
2018-02-08 08:41:08.020 UTC [common/configtx/tool] doOutputChannelCreateTx -> INFO 003 Writing new channel tx				
				]]>
				</screen>
			</section>
			<section id="">
				<title> generate anchor peer transaction</title>
				<para>命令</para>
				<screen>
				<![CDATA[
CHANNEL_NAME=mychannel
configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP				
				]]>
				</screen>
				<para>操作演示</para>
				<screen>
				<![CDATA[
root@8f467a88de99:~/netkiller# CHANNEL_NAME=mychannel
root@8f467a88de99:~/netkiller# configtxgen -profile OneOrgChannel -outputAnchorPeersUpdate ./config/Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP
2018-02-08 08:46:19.162 UTC [common/configtx/tool] main -> INFO 001 Loading configuration
2018-02-08 08:46:19.176 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -> INFO 002 Generating anchor peer update
2018-02-08 08:46:19.177 UTC [common/configtx/tool] doOutputAnchorPeersUpdate -> INFO 003 Writing anchor peer update
				]]>
				</screen>
			</section>
			<section id="">
				<title>清理 Docker 容器</title>
				<para>至此所需的证书与创世区块都已生产完毕，fabric-tools 容易完成了它的使命，你可以继续保留或者清理干净。</para>
				<screen>
				<![CDATA[
[root@localhost netkiller]# docker-compose -f docker-compose-fabric-tools.yml down
Stopping tools ... done
Removing tools ... done
Removing network netkiller_basic
				]]>
				</screen>
				<para>清理 fabric-tools 容器</para>
				<screen>
				<![CDATA[
docker rm -f $(docker ps -qa)
				]]>
				</screen>
			</section>
		</section>

	</section>
	<section id="couchdb">
		<title>CouchDB 节点</title>
		<para>整个 Hyperledger Fabric 技术栈中只有这个 CouchDB 是个外来户，看到 CouchDB
			我就非常兴奋，这是一个NoSQL数据库(它与MongoDB十分类似)，所以CouchDB 100%可以独立运行，且最容易分离。</para>
		<para>CouchDB 在这里有两个方案可以选择。</para>
		<itemizedlist>
			<title></title>
			<listitem>
				<para>采用 Docker 运行 CouchDB的方案。</para>
			</listitem>
			<listitem>
				<para>采用传统方式物理机上本地安装 CouchDB</para>
			</listitem>
		</itemizedlist>
		<para>理论两种方案对实际结果没有什么区别，只需提供IP地址，用户名与密码供其他节点访问即可。但实际我们看到 Hyperledger
			Fabric 使用的镜像是 hyperledger/fabric-couchdb 不清楚是否有修改过 CouchDB 数据库。</para>
		<para>如果你对 Docker 比较熟悉就采用 Docker
			方案。如果不熟悉就采用本地安装方式。总之选择一种你能Hold住（掌控）的方案，一旦出现故障，你能第一时间排查并处理。</para>

		<section id="">
			<title>安装 CouchDB</title>
			<para>下面是 Docker 方案</para>
			<screen>
			<![CDATA[
[root@localhost netkiller]# vim docker-compose-couchdb.yml
		
version: '2'

networks:
  basic:

services:
  couchdb:
    container_name: couchdb
    image: hyperledger/fabric-couchdb
    # Populate the COUCHDB_USER and COUCHDB_PASSWORD to set an admin user and password
    # for CouchDB.  This will prevent CouchDB from operating in an "Admin Party" mode.
    environment:
      - COUCHDB_USER=admin
      - COUCHDB_PASSWORD=passw0rd
    ports:
      - 172.16.0.17:5984:5984
    networks:
      - basic
			]]>
			</screen>
		</section>
		<section id="">
			<title>启动 CouchDB</title>
			<para>启动 Docker 容器</para>
			<screen>
			<![CDATA[
docker-compose -f docker-compose-couchdb.yml up -d		
			]]>
			</screen>
			<para>访问CouchDB管理界面，http://172.16.0.17:5984/_utils/
				请使用上面设置的密码进入。若想进入到容器内部可以使用下面命令：</para>
			<screen>
			<![CDATA[
docker-compose -f docker-compose-couchdb.yml exec couchdb bash	
			]]>
			</screen>
			<para>至此 CouchDB 节点部署完毕。</para>
		</section>
		<section id="">
			<title>备份与恢复 CouchDB </title>
			<para>既然是运维区块链，对于运维工作我们最关心的就是如何备份数据，在出现故障的时候恢复数据。</para>
			<screen>
			<![CDATA[
npm install --save couchdb-backup-restore			
			]]>
			</screen>
			<screen>
			<![CDATA[
var cbr = require('couchdb-backup-restore');
 
var config = {credentials: 'http://localhost:5984'};
 
function done(err) {
  if (err) {
    return console.error(err);
  }
  console.log('all done!');
}
 
// backup 
cbr.backup(config, done).pipe(fs.createWriteStream('./db-backup.tar.gz'))

// restore 
fs.createReadStream('./db-backup.tar.gz').pipe(cbr.restore(config, done));
			]]>
			</screen>
			
		</section>

	</section>

	<section id="orderer">
		<title>Orderer 节点安装</title>
		<para></para>
	</section>

	<section id="peer">
		<title>Peer 节点安装</title>
		<para></para>
	</section>
	<section id="ca">
		<title>CA 节点安装</title>
		<para></para>
	</section>
	<section id="tools">
		<title>Tools 节点安装</title>
		<para></para>
	</section>
	<section id="test">
		<title>验收与测试</title>
	</section>
	<section id="summary">
		<title>总结</title>
	</section>
	<!-- Conclusion -->
</article>
